from __future__ import annotations

import argparse
import json
import os
import sys
from pathlib import Path

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from algorithms.river_mccfr import ExternalSamplingMCCFRTrainer, RiverMCCFRConfig
from algorithms.vector_cfr import VectorCFRConfig, VectorCFRTrainer
from algorithms.vector_eval import build_blocked_indices, build_strength_summary, exploitability
from algorithms.vector_fp import VectorFPConfig, VectorFictitiousPlayTrainer
from games.river_holdem import RiverHoldemConfig, RiverHoldemGame, card_str


CHECKPOINTS = [25, 50, 100, 200, 400, 800, 1600]


def run_trainer(trainer, game, summaries, blocked_indices, target_exp: float | None):
    results = {}
    completed = 0
    checkpoints = list(CHECKPOINTS)
    idx = 0
    last_profile = None
    while True:
        if idx < len(checkpoints):
            target = checkpoints[idx]
        else:
            if target_exp is None:
                break
            target = max(1, completed * 2)
        trainer.run(target - completed)
        completed = target
        profile = trainer.average_strategy_profile()
        last_profile = profile
        results[target] = exploitability(game, profile, summaries, blocked_indices)
        if target_exp is not None and results[target] <= target_exp:
            break
        idx += 1
    return results, last_profile


def write_strategy_json(path: Path, game: RiverHoldemGame, profile) -> None:
    players = []
    for player in (0, 1):
        hands = [card_str(hand.cards[0]) + card_str(hand.cards[1]) for hand in game.hands[player]]
        weights = list(game.hand_weights[player])
        player_profile = {}
        for key, (actions, matrix) in profile[player].items():
            player_profile[key] = {"actions": actions, "strategy": matrix}
        players.append({"hands": hands, "weights": weights, "profile": player_profile})
    with path.open("w", encoding="utf-8") as out:
        json.dump({"players": players}, out, indent=2)


def main() -> None:
    parser = argparse.ArgumentParser(description="Run river exploitability checkpoints.")
    parser.add_argument("--config", type=Path, default=None, help="Load a subgame config JSON.")
    parser.add_argument("--target-exp", type=float, default=None, help="Stop when exploitability <= target.")
    parser.add_argument("--dump-strategy", type=Path, default=None, help="Write the final average strategy to JSON.")
    parser.add_argument(
        "--algo",
        default="all",
        choices=("all", "cfr", "cfr+", "dcfr", "fp", "mccfr"),
        help="Algorithm to run.",
    )
    args = parser.parse_args()

    if args.dump_strategy and args.algo == "all":
        raise SystemExit("--dump-strategy requires --algo (not 'all').")

    if args.config:
        with args.config.open("r", encoding="utf-8") as f:
            data = json.load(f)
        board = tuple(data.get("board") or ["Ks", "Th", "7s", "4d", "2s"])
        pot = int(data.get("pot", 1000))
        stack = int(data.get("stack", 9500))
        bet_sizes = tuple(data.get("bet_sizes") or [0.5, 1.0])
        include_all_in = bool(data.get("include_all_in", True))
        max_raises = int(data.get("max_raises", 1000))
        oop_first_bets = data.get("oop_first_bets") or None
        ip_first_bets = data.get("ip_first_bets") or None
        oop_first_raises = data.get("oop_first_raises") or None
        ip_first_raises = data.get("ip_first_raises") or None
        oop_next_raises = data.get("oop_next_raises") or None
        ip_next_raises = data.get("ip_next_raises") or None
        ranges = [None, None]
        weights = [None, None]
        players = data.get("players")
        if isinstance(players, list) and len(players) == 2:
            for idx, entry in enumerate(players):
                if not isinstance(entry, dict):
                    continue
                hands = entry.get("hands")
                hand_weights = entry.get("weights")
                if isinstance(hands, list) and isinstance(hand_weights, list) and len(hands) == len(hand_weights):
                    ranges[idx] = hands
                    weights[idx] = hand_weights
        config = RiverHoldemConfig(
            board=board,
            pot=pot,
            stacks=(stack, stack),
            bet_sizes=bet_sizes,
            oop_first_bets=oop_first_bets,
            ip_first_bets=ip_first_bets,
            oop_first_raises=oop_first_raises,
            ip_first_raises=ip_first_raises,
            oop_next_raises=oop_next_raises,
            ip_next_raises=ip_next_raises,
            include_all_in=include_all_in,
            max_raises=max_raises,
            ranges=(ranges[0], ranges[1]),
            range_weights=(weights[0], weights[1]),
        )
    else:
        config = RiverHoldemConfig(
            board=("Ks", "Th", "7s", "4d", "2s"),
            pot=1000,
            stacks=(9500, 9500),
            bet_sizes=(0.5, 1.0),
            include_all_in=True,
            max_raises=1000,
        )
    game = RiverHoldemGame(config)
    summaries = {
        0: build_strength_summary(game.hands[1]),
        1: build_strength_summary(game.hands[0]),
    }
    blocked_indices = {
        0: build_blocked_indices(game.hands[0], summaries[0]),
        1: build_blocked_indices(game.hands[1], summaries[1]),
    }

    algorithms = {
        "cfr": lambda g: VectorCFRTrainer(g, VectorCFRConfig(use_plus=False, linear_weighting=False, alternating=True)),
        "cfr+": lambda g: VectorCFRTrainer(g, VectorCFRConfig(use_plus=True, linear_weighting=True, alternating=True)),
        "dcfr": lambda g: VectorCFRTrainer(
            g,
            VectorCFRConfig(
                use_plus=False,
                linear_weighting=False,
                alternating=True,
                use_dcfr=True,
                dcfr_alpha=1.5,
                dcfr_beta=0.0,
                dcfr_gamma=2.0,
            ),
        ),
        "fp": lambda g: VectorFictitiousPlayTrainer(
            g, VectorFPConfig(optimistic=False, linear_weighting=False, alternating=True)
        ),
        "mccfr": lambda g: ExternalSamplingMCCFRTrainer(g, RiverMCCFRConfig(seed=7)),
    }

    print("Game: river_nlth")
    for name, trainer_factory in algorithms.items():
        if args.algo != "all" and name != args.algo:
            continue
        trainer = trainer_factory(game)
        results, profile = run_trainer(trainer, game, summaries, blocked_indices, args.target_exp)
        values = " ".join(f"{results[it]:.6f}" for it in results)
        print(f"  {name}: {values}")
        if args.dump_strategy and profile is not None:
            write_strategy_json(args.dump_strategy, game, profile)
            print(f"  dumped strategy to {args.dump_strategy}")


if __name__ == "__main__":
    main()
