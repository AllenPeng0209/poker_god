from __future__ import annotations

import argparse
import json
import os
import sys
from pathlib import Path

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from algorithms.cfr import CFRConfig, CFRTrainer
from algorithms.evaluation import exploitability
from algorithms.fictitious_play import FPConfig, FictitiousPlayTrainer
from algorithms.mccfr import ExternalSamplingMCCFRTrainer, MCCFRConfig
from games.kuhn import KuhnPoker
from games.leduc import LeducPoker


CHECKPOINTS = [25, 50, 100, 200, 400, 800, 1600]


def run_trainer(trainer, game, target_exp: float | None):
    results = {}
    completed = 0
    checkpoints = list(CHECKPOINTS)
    idx = 0
    last_profile = None
    while True:
        if idx < len(checkpoints):
            target = checkpoints[idx]
        else:
            if target_exp is None:
                break
            target = max(1, completed * 2)
        trainer.run(target - completed)
        completed = target
        profile = trainer.average_strategy_profile()
        last_profile = profile
        results[target] = exploitability(game, profile)
        if target_exp is not None and results[target] <= target_exp:
            break
        idx += 1
    return results, last_profile


def _label_fp(config: FPConfig) -> str:
    parts = ["fp"]
    if config.optimistic:
        parts.append("opt")
    if config.linear_weighting:
        parts.append("lin")
    if config.alternating:
        parts.append("alt")
    if len(parts) == 1:
        return "fp"
    return "fp(" + ",".join(parts[1:]) + ")"


def main() -> None:
    parser = argparse.ArgumentParser(description="Run exploitability checkpoints.")
    parser.add_argument("--optimistic", action="store_true", help="Optimistic FP (double-weight last iterate).")
    parser.add_argument("--linear", action="store_true", default=True, help="Use linear weighting where supported.")
    parser.add_argument("--no-linear", dest="linear", action="store_false", help="Disable linear weighting.")
    parser.add_argument(
        "--no-alternating",
        dest="alternating",
        action="store_false",
        help="Disable alternating CFR/CFR+ table and FP alternating updates.",
    )
    parser.add_argument("--target-exp", type=float, default=None, help="Stop when exploitability <= target.")
    parser.add_argument("--dump-strategy", type=Path, default=None, help="Write the final average strategy to JSON.")
    parser.add_argument(
        "--algo",
        default="all",
        choices=("all", "cfr", "cfr+", "dcfr", "mccfr", "fp"),
        help="Algorithm to run.",
    )
    parser.add_argument(
        "--game",
        default="all",
        choices=("all", "kuhn", "leduc"),
        help="Game to run.",
    )
    parser.set_defaults(alternating=True)
    args = parser.parse_args()
    if args.dump_strategy and args.algo == "all":
        raise SystemExit("--dump-strategy requires --algo (not 'all').")
    if args.dump_strategy and args.game == "all":
        raise SystemExit("--dump-strategy requires --game (not 'all').")

    games = {
        "kuhn": KuhnPoker(),
        "leduc": LeducPoker(),
    }
    fp_config = FPConfig(
        optimistic=args.optimistic,
        linear_weighting=args.linear,
        alternating=args.alternating,
    )

    algorithms = {
        "cfr": lambda g: CFRTrainer(g, CFRConfig(use_plus=False, linear_weighting=False, alternating=False)),
        "cfr+": lambda g: CFRTrainer(g, CFRConfig(use_plus=True, linear_weighting=args.linear, alternating=False)),
        "dcfr": lambda g: CFRTrainer(
            g,
            CFRConfig(
                use_plus=False,
                linear_weighting=False,
                alternating=False,
                use_dcfr=True,
                dcfr_alpha=1.5,
                dcfr_beta=0.0,
                dcfr_gamma=2.0,
            ),
        ),
        "mccfr": lambda g: ExternalSamplingMCCFRTrainer(g, MCCFRConfig(seed=7)),
        _label_fp(fp_config): lambda g: FictitiousPlayTrainer(g, fp_config),
    }

    alt_algorithms = {
        "cfr": lambda g: CFRTrainer(g, CFRConfig(use_plus=False, linear_weighting=False, alternating=True)),
        "cfr+": lambda g: CFRTrainer(g, CFRConfig(use_plus=True, linear_weighting=args.linear, alternating=True)),
    }

    for game_name, game in games.items():
        if args.game != "all" and game_name != args.game:
            continue
        print(f"Game: {game_name}")
        for algo_name, trainer_factory in algorithms.items():
            normalized_name = algo_name
            if algo_name.startswith("fp"):
                normalized_name = "fp"
            if args.algo != "all" and normalized_name != args.algo:
                continue
            trainer = trainer_factory(game)
            results, profile = run_trainer(trainer, game, args.target_exp)
            values = " ".join(f"{results[it]:.6f}" for it in results)
            print(f"  {algo_name}: {values}")
            if args.dump_strategy and profile is not None:
                with args.dump_strategy.open("w", encoding="utf-8") as out:
                    json.dump(profile, out, indent=2)
                print(f"  dumped strategy to {args.dump_strategy}")
        if args.alternating:
            print("  alternating:")
            for algo_name, trainer_factory in alt_algorithms.items():
                if args.algo != "all" and algo_name != args.algo:
                    continue
                trainer = trainer_factory(game)
                results, _ = run_trainer(trainer, game, args.target_exp)
                values = " ".join(f"{results[it]:.6f}" for it in results)
                print(f"    {algo_name}: {values}")
        print()


if __name__ == "__main__":
    main()
